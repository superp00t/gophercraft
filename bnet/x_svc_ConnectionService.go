// generated by protoc-gen-gcraft : DO NOT EDIT
package bnet

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	protocol "github.com/superp00t/gophercraft/bnet/bgs/protocol"
	v1 "github.com/superp00t/gophercraft/bnet/bgs/protocol/connection/v1"
	math "math"
)

// shut the compiler up
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf
var _ = protocol.E_MethodOptions

const ConnectionServiceHash = 0x65446991

type ConnectionService interface {
	Connect(*Conn, uint32, *v1.ConnectRequest)
	Bind(*Conn, uint32, *v1.BindRequest)
	Echo(*Conn, uint32, *v1.EchoRequest)
	ForceDisconnect(*Conn, uint32, *v1.DisconnectNotification)
	KeepAlive(*Conn, uint32, *protocol.NoData)
	Encrypt(*Conn, uint32, *v1.EncryptRequest)
	RequestDisconnect(*Conn, uint32, *v1.DisconnectRequest)
}

func DispatchConnectionService(conn *Conn, svc ConnectionService, token uint32, method uint32, data []byte) error {
	switch method {
	case 1:
		var args v1.ConnectRequest
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.Connect(conn, token, &args)
	case 2:
		var args v1.BindRequest
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.Bind(conn, token, &args)
	case 3:
		var args v1.EchoRequest
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.Echo(conn, token, &args)
	case 4:
		var args v1.DisconnectNotification
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.ForceDisconnect(conn, token, &args)
	case 5:
		var args protocol.NoData
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.KeepAlive(conn, token, &args)
	case 6:
		var args v1.EncryptRequest
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.Encrypt(conn, token, &args)
	case 7:
		var args v1.DisconnectRequest
		err := proto.Unmarshal(data, &args)
		if err != nil {
			return err
		}
		svc.RequestDisconnect(conn, token, &args)
	}
	return nil
}

type EmptyConnectionService struct{}

func (e EmptyConnectionService) Connect(conn *Conn, token uint32, args *v1.ConnectRequest) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}
func (e EmptyConnectionService) Bind(conn *Conn, token uint32, args *v1.BindRequest) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}
func (e EmptyConnectionService) Echo(conn *Conn, token uint32, args *v1.EchoRequest) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}
func (e EmptyConnectionService) ForceDisconnect(conn *Conn, token uint32, args *v1.DisconnectNotification) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}
func (e EmptyConnectionService) KeepAlive(conn *Conn, token uint32, args *protocol.NoData) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}
func (e EmptyConnectionService) Encrypt(conn *Conn, token uint32, args *v1.EncryptRequest) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}
func (e EmptyConnectionService) RequestDisconnect(conn *Conn, token uint32, args *v1.DisconnectRequest) {
	conn.SendResponseCode(token, ERROR_RPC_NOT_IMPLEMENTED)
}

func (c *Conn) ConnectionService_Request_Connect(args *v1.ConnectRequest) (*v1.ConnectResponse, error) {
	header, bytes, err := c.Request(ConnectionServiceHash, 1, args)
	if err != nil {
		return nil, err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return nil, fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	var out v1.ConnectResponse
	err = proto.Unmarshal(bytes, &out)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *Conn) ConnectionService_Request_Bind(args *v1.BindRequest) (*v1.BindResponse, error) {
	header, bytes, err := c.Request(ConnectionServiceHash, 2, args)
	if err != nil {
		return nil, err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return nil, fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	var out v1.BindResponse
	err = proto.Unmarshal(bytes, &out)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *Conn) ConnectionService_Request_Echo(args *v1.EchoRequest) (*v1.EchoResponse, error) {
	header, bytes, err := c.Request(ConnectionServiceHash, 3, args)
	if err != nil {
		return nil, err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return nil, fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	var out v1.EchoResponse
	err = proto.Unmarshal(bytes, &out)
	if err != nil {
		return nil, err
	}
	return &out, nil
}

func (c *Conn) ConnectionService_Request_ForceDisconnect(args *v1.DisconnectNotification) error {
	header, _, err := c.Request(ConnectionServiceHash, 4, args)
	if err != nil {
		return err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	return nil
}

func (c *Conn) ConnectionService_Request_KeepAlive() error {
	header, _, err := c.Request(ConnectionServiceHash, 5, nil)
	if err != nil {
		return err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	return nil
}

func (c *Conn) ConnectionService_Request_Encrypt(args *v1.EncryptRequest) error {
	header, _, err := c.Request(ConnectionServiceHash, 6, args)
	if err != nil {
		return err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	return nil
}

func (c *Conn) ConnectionService_Request_RequestDisconnect(args *v1.DisconnectRequest) error {
	header, _, err := c.Request(ConnectionServiceHash, 7, args)
	if err != nil {
		return err
	}
	if Status(header.GetStatus()) != ERROR_OK {
		return fmt.Errorf("bnet: non-ok status 0x%08X", header.GetStatus())
	}
	return nil
}
